<?xml version="1.0" encoding="utf-8"?>
<OverloadingSymbols>
  <Symbols Key="vl.collections.LazyList`1">
    <TemplateDecl Access="Public" Tags="x86, Windows">
      <Document>&lt;Document&gt;
  &lt;summary&gt;A lazy evaluated readonly container.&lt;/summary&gt;
  &lt;typeparam name="T"&gt;The type of elements.&lt;/typeparam&gt;
&lt;/Document&gt;</Document>
      <TypeParameters>
        <TypeParameterDecl Access="Public" Name="T" Tags="x86, Windows" NameKey="::vl::collections::T" OverloadKey="::vl::collections::LazyList`1::T" />
      </TypeParameters>
      <Specialization />
      <Element>
        <ClassDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList" OverloadKey="::vl::collections::LazyList`1" ClassType="Class">
          <Children>
            <VarDecl Access="Protected" Name="enumeratorPrototype" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::enumeratorPrototype" OverloadKey="::vl::collections::LazyList`1::enumeratorPrototype" Static="False">
              <Type>
                <GenericTypeDecl>
                  <Element>
                    <RefTypeDecl ReferencingNameKey="::vl::Ptr" Name="Ptr">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::Ptr`1@s:vl.Ptr`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Element>
                  <TypeArguments>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerator" Name="IEnumerator">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::IEnumerator`1@s:vl.collections.IEnumerator`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </TypeArguments>
                </GenericTypeDecl>
              </Type>
            </VarDecl>
            <TemplateDecl Access="Protected" Tags="x86, Windows">
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="U" Tags="x86, Windows" NameKey="::vl::collections::LazyList::U" OverloadKey="::vl::collections::LazyList`1::Element`1(&amp; const IEnumerable&lt;U&gt;)::U" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Element" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Element" OverloadKey="::vl::collections::LazyList`1::Element`1(&amp; const IEnumerable&lt;U&gt;)" Virtual="Static" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="False">
                      <ReturnType>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::Element`1(&amp; const IEnumerable&lt;U&gt;)::U@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Element::" OverloadKey="::vl::collections::LazyList`1::Element`1(&amp; const IEnumerable&lt;U&gt;)::" Static="False">
                          <Type>
                            <DecorateTypeDecl Decoration="LeftRef">
                              <Element>
                                <DecorateTypeDecl Decoration="Const">
                                  <Element>
                                    <GenericTypeDecl>
                                      <Element>
                                        <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </Element>
                                      <TypeArguments>
                                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::collections::LazyList`1::Element`1(&amp; const IEnumerable&lt;U&gt;)::U@s:vl.collections.LazyList`1" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </TypeArguments>
                                    </GenericTypeDecl>
                                  </Element>
                                </DecorateTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <FuncDecl Access="Protected" Name="xs" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::xs" OverloadKey="::vl::collections::LazyList`1::xs()const" Virtual="Normal" Function="Function">
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <DecorateTypeDecl Decoration="Pointer">
                      <Element>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerator" Name="IEnumerator">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::IEnumerator`1@s:vl.collections.IEnumerator`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList(* IEnumerator&lt;T&gt;)" Virtual="Normal" Function="Constructor">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a lazy list with an enumerator.&lt;/summary&gt;
  &lt;param name="enumerator"&gt;The enumerator.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <RefTypeDecl Name="void" />
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="enumerator" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList::enumerator" OverloadKey="::vl::collections::LazyList`1::LazyList(* IEnumerator&lt;T&gt;)::enumerator" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="Pointer">
                          <Element>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerator" Name="IEnumerator">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::IEnumerator`1@s:vl.collections.IEnumerator`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList(Ptr&lt;IEnumerator&lt;T&gt;&gt;)" Virtual="Normal" Function="Constructor">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a lazy list with an enumerator.&lt;/summary&gt;
  &lt;param name="enumerator"&gt;The enumerator.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <RefTypeDecl Name="void" />
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="enumerator" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList::enumerator" OverloadKey="::vl::collections::LazyList`1::LazyList(Ptr&lt;IEnumerator&lt;T&gt;&gt;)::enumerator" Static="False">
                      <Type>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::Ptr" Name="Ptr">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::Ptr`1@s:vl.Ptr`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerator" Name="IEnumerator">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::IEnumerator`1@s:vl.collections.IEnumerator`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList(&amp; const IEnumerable&lt;T&gt;)" Virtual="Normal" Function="Constructor">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a lazy list with an enumerable.&lt;/summary&gt;
  &lt;param name="enumerable"&gt;The enumerator.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <RefTypeDecl Name="void" />
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="enumerable" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList::enumerable" OverloadKey="::vl::collections::LazyList`1::LazyList(&amp; const IEnumerable&lt;T&gt;)::enumerable" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList(&amp; const LazyList&lt;T&gt;)" Virtual="Normal" Function="Constructor">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a lazy list with an lazy list.&lt;/summary&gt;
  &lt;param name="lazyList"&gt;The lazy list.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <RefTypeDecl Name="void" />
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="lazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList::lazyList" OverloadKey="::vl::collections::LazyList`1::LazyList(&amp; const LazyList&lt;T&gt;)::lazyList" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a lazy list with a container.&lt;/summary&gt;
  &lt;typeparam name="TContainer"&gt;Type of the container.&lt;/typeparam&gt;
  &lt;param name="container"&gt;The container.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="TContainer" Tags="x86, Windows" NameKey="::vl::collections::LazyList::TContainer" OverloadKey="::vl::collections::LazyList`1::LazyList`1(Ptr&lt;TContainer&gt;)::TContainer" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList`1(Ptr&lt;TContainer&gt;)" Virtual="Normal" Function="Constructor">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="False">
                      <ReturnType>
                        <RefTypeDecl Name="void" />
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="container" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList::container" OverloadKey="::vl::collections::LazyList`1::LazyList`1(Ptr&lt;TContainer&gt;)::container" Static="False">
                          <Type>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::Ptr" Name="Ptr">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::Ptr`1@s:vl.Ptr`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::TContainer" Name="TContainer">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::LazyList`1(Ptr&lt;TContainer&gt;)::TContainer@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <FuncDecl Access="Public" Name="LazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::LazyList" OverloadKey="::vl::collections::LazyList`1::LazyList()" Virtual="Normal" Function="Constructor">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create an empty lazy list.&lt;/summary&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <RefTypeDecl Name="void" />
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="operator =" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::operator =" OverloadKey="::vl::collections::LazyList`1::operator =(&amp; const LazyList&lt;T&gt;)" Virtual="Normal" Function="Function">
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="False">
                  <ReturnType>
                    <DecorateTypeDecl Decoration="LeftRef">
                      <Element>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="lazyList" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::operator =::lazyList" OverloadKey="::vl::collections::LazyList`1::operator =(&amp; const LazyList&lt;T&gt;)::lazyList" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="CreateEnumerator" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::CreateEnumerator" OverloadKey="::vl::collections::LazyList`1::CreateEnumerator()const" Virtual="Normal" Function="Function">
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <DecorateTypeDecl Decoration="Pointer">
                      <Element>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerator" Name="IEnumerator">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::IEnumerator`1@s:vl.collections.IEnumerator`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </Element>
                    </DecorateTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements transformed.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a transformation function.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::Select`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Select" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Select" OverloadKey="::vl::collections::LazyList`1::Select`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType::ResultType" Name="ResultType">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                                <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                              </ReferencingOverloadKeys>
                              <Parent>
                                <GenericTypeDecl>
                                  <Element>
                                    <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType" Name="FunctionObjectRetriveType">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                                        <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                                      </ReferencingOverloadKeys>
                                      <Parent>
                                        <SubTypeDecl ReferencingNameKey="::vl::function_lambda" Name="function_lambda">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::function_lambda@ns:vl.function_lambda" />
                                          </ReferencingOverloadKeys>
                                          <Parent>
                                            <RefTypeDecl ReferencingNameKey="::vl" Name="vl">
                                              <ReferencingOverloadKeys>
                                                <Key Value="::vl@ns:vl" />
                                              </ReferencingOverloadKeys>
                                            </RefTypeDecl>
                                          </Parent>
                                        </SubTypeDecl>
                                      </Parent>
                                    </SubTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::Select`1(F)const::F@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Parent>
                            </SubTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Select::f" OverloadKey="::vl::collections::LazyList`1::Select`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Select`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements that satisfy with a condition.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a filter.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::Where`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Where" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Where" OverloadKey="::vl::collections::LazyList`1::Where`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Where::f" OverloadKey="::vl::collections::LazyList`1::Where`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Where`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements casted to a new type.&lt;/summary&gt;
  &lt;typeparam name="U"&gt;The new type.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="U" Tags="x86, Windows" NameKey="::vl::collections::LazyList::U" OverloadKey="::vl::collections::LazyList`1::Cast`1()const::U" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Cast" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Cast" OverloadKey="::vl::collections::LazyList`1::Cast`1()const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::Ptr" Name="Ptr">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::Ptr`1@s:vl.Ptr`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::Cast`1()const::U@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters />
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with only elements that successfully casted to a new type.&lt;/summary&gt;
  &lt;typeparam name="U"&gt;The new type.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="U" Tags="x86, Windows" NameKey="::vl::collections::LazyList::U" OverloadKey="::vl::collections::LazyList`1::FindType`1()const::U" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="FindType" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::FindType" OverloadKey="::vl::collections::LazyList`1::FindType`1()const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::Ptr" Name="Ptr">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::Ptr`1@s:vl.Ptr`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::FindType`1()const::U@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters />
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements sorted.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a comparing function.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::OrderBy`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="OrderBy" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::OrderBy" OverloadKey="::vl::collections::LazyList`1::OrderBy`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::OrderBy::f" OverloadKey="::vl::collections::LazyList`1::OrderBy`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::OrderBy`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Aggregate a lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The aggregated value.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as an aggregator.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::Aggregate`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Aggregate" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Aggregate" OverloadKey="::vl::collections::LazyList`1::Aggregate`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Aggregate::f" OverloadKey="::vl::collections::LazyList`1::Aggregate`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Aggregate`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Aggregate a lazy list.&lt;/summary&gt;
  &lt;typeparam name="I"&gt;Type of the initial value.&lt;/typeparam&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The aggregated value.&lt;/returns&gt;
  &lt;param name="init"&gt;The initial value that is virtually added before the lazy list.&lt;/param&gt;
  &lt;param name="f"&gt;The lambda expression as an aggregator.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="I" Tags="x86, Windows" NameKey="::vl::collections::LazyList::I" OverloadKey="::vl::collections::LazyList`1::Aggregate`2(I,F)const::I" />
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::Aggregate`2(I,F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Aggregate" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Aggregate" OverloadKey="::vl::collections::LazyList`1::Aggregate`2(I,F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::I" Name="I">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::Aggregate`2(I,F)const::I@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="init" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Aggregate::init" OverloadKey="::vl::collections::LazyList`1::Aggregate`2(I,F)const::init" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::I" Name="I">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Aggregate`2(I,F)const::I@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Aggregate::f" OverloadKey="::vl::collections::LazyList`1::Aggregate`2(I,F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Aggregate`2(I,F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Test does all elements in the lazy list satisfy with a condition.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;Returns true if all elements satisfy with a condition.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a filter.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::All`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="All" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::All" OverloadKey="::vl::collections::LazyList`1::All`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <RefTypeDecl Name="bool" />
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::All::f" OverloadKey="::vl::collections::LazyList`1::All`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::All`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Test does any elements in the lazy list satisfy with a condition.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;Returns true if at least one element satisfies with a condition.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a filter.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::Any`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Any" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Any" OverloadKey="::vl::collections::LazyList`1::Any`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <RefTypeDecl Name="bool" />
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Any::f" OverloadKey="::vl::collections::LazyList`1::Any`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::Any`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <FuncDecl Access="Public" Name="Max" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Max" OverloadKey="::vl::collections::LazyList`1::Max()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the maximum value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;
  &lt;returns&gt;The maximum value.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Min" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Min" OverloadKey="::vl::collections::LazyList`1::Min()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the minimum value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;
  &lt;returns&gt;The minimum value.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="First" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::First" OverloadKey="::vl::collections::LazyList`1::First()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the first value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;
  &lt;returns&gt;The first value.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="First" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::First" OverloadKey="::vl::collections::LazyList`1::First(T)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the first value in the lazy list.&lt;/summary&gt;
  &lt;returns&gt;The first value.&lt;/returns&gt;
  &lt;param name="defaultValue"&gt;Returns this argument if the lazy list is empty.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="defaultValue" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::First::defaultValue" OverloadKey="::vl::collections::LazyList`1::First(T)const::defaultValue" Static="False">
                      <Type>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Last" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Last" OverloadKey="::vl::collections::LazyList`1::Last()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the last value in the lazy list. An exception will raise if the lazy list is empty.&lt;/summary&gt;
  &lt;returns&gt;The last value.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Last" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Last" OverloadKey="::vl::collections::LazyList`1::Last(T)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the last value in the lazy list.&lt;/summary&gt;
  &lt;returns&gt;The last value.&lt;/returns&gt;
  &lt;param name="defaultValue"&gt;Returns this argument if the lazy list is empty.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="defaultValue" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Last::defaultValue" OverloadKey="::vl::collections::LazyList`1::Last(T)const::defaultValue" Static="False">
                      <Type>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Count" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Count" OverloadKey="::vl::collections::LazyList`1::Count()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Get the number of elements in the lazy list.&lt;/summary&gt;
  &lt;returns&gt;The number of elements.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl ReferencingNameKey="::vl::vint" Name="vint">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::vint@s:vl.vint" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="IsEmpty" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::IsEmpty" OverloadKey="::vl::collections::LazyList`1::IsEmpty()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Test is the lazy list empty.&lt;/summary&gt;
  &lt;returns&gt;Returns true if the lazy list is empty.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <RefTypeDecl Name="bool" />
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Concat" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Concat" OverloadKey="::vl::collections::LazyList`1::Concat(&amp; const IEnumerable&lt;T&gt;)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list containing elements of the two container one after another.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="remains"&gt;Elements that put after this lazy list.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="remains" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Concat::remains" OverloadKey="::vl::collections::LazyList`1::Concat(&amp; const IEnumerable&lt;T&gt;)const::remains" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Take" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Take" OverloadKey="::vl::collections::LazyList`1::Take(vint)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with some prefix elements.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="count"&gt;The size of the prefix.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="count" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Take::count" OverloadKey="::vl::collections::LazyList`1::Take(vint)const::count" Static="False">
                      <Type>
                        <RefTypeDecl ReferencingNameKey="::vl::vint" Name="vint">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::vint@s:vl.vint" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Skip" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Skip" OverloadKey="::vl::collections::LazyList`1::Skip(vint)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list without some prefix elements.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="count"&gt;The size of the prefix.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="count" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Skip::count" OverloadKey="::vl::collections::LazyList`1::Skip(vint)const::count" Static="False">
                      <Type>
                        <RefTypeDecl ReferencingNameKey="::vl::vint" Name="vint">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::vint@s:vl.vint" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Repeat" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Repeat" OverloadKey="::vl::collections::LazyList`1::Repeat(vint)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with several copies of this lazy list one after another.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="count"&gt;The numbers of copies.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="count" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Repeat::count" OverloadKey="::vl::collections::LazyList`1::Repeat(vint)const::count" Static="False">
                      <Type>
                        <RefTypeDecl ReferencingNameKey="::vl::vint" Name="vint">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::vint@s:vl.vint" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Distinct" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Distinct" OverloadKey="::vl::collections::LazyList`1::Distinct()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements in this lazy list. If some elements appear several times, only one will be kept.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Reverse" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Reverse" OverloadKey="::vl::collections::LazyList`1::Reverse()const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with all elements in this lazy list in a reverse order.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list of pairs from elements from two containers.&lt;/summary&gt;
  &lt;typeparam name="U"&gt;Type of all elements in the second container.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="remains"&gt;The second container.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="U" Tags="x86, Windows" NameKey="::vl::collections::LazyList::U" OverloadKey="::vl::collections::LazyList`1::Pairwise`1(&amp; const IEnumerable&lt;U&gt;)const::U" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="Pairwise" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Pairwise" OverloadKey="::vl::collections::LazyList`1::Pairwise`1(&amp; const IEnumerable&lt;U&gt;)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::Pair" Name="Pair">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::Pair`2@s:vl.collections.Pair`2" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::Pairwise`1(&amp; const IEnumerable&lt;U&gt;)const::U@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="remains" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Pairwise::remains" OverloadKey="::vl::collections::LazyList`1::Pairwise`1(&amp; const IEnumerable&lt;U&gt;)const::remains" Static="False">
                          <Type>
                            <DecorateTypeDecl Decoration="LeftRef">
                              <Element>
                                <DecorateTypeDecl Decoration="Const">
                                  <Element>
                                    <GenericTypeDecl>
                                      <Element>
                                        <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </Element>
                                      <TypeArguments>
                                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::U" Name="U">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::collections::LazyList`1::Pairwise`1(&amp; const IEnumerable&lt;U&gt;)const::U@s:vl.collections.LazyList`1" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </TypeArguments>
                                    </GenericTypeDecl>
                                  </Element>
                                </DecorateTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <FuncDecl Access="Public" Name="Intersect" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Intersect" OverloadKey="::vl::collections::LazyList`1::Intersect(&amp; const IEnumerable&lt;T&gt;)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with only elements that appear in both containers.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="remains"&gt;The second container.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="remains" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Intersect::remains" OverloadKey="::vl::collections::LazyList`1::Intersect(&amp; const IEnumerable&lt;T&gt;)const::remains" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Except" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Except" OverloadKey="::vl::collections::LazyList`1::Except(&amp; const IEnumerable&lt;T&gt;)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with only elements that appear in this lazy list but not in another container.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="remains"&gt;The second container.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="remains" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Except::remains" OverloadKey="::vl::collections::LazyList`1::Except(&amp; const IEnumerable&lt;T&gt;)const::remains" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Union" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Union" OverloadKey="::vl::collections::LazyList`1::Union(&amp; const IEnumerable&lt;T&gt;)const" Virtual="Normal" Function="Function">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list with elements in two containers. If some elements appear several times, only one will be kept.&lt;/summary&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="remains"&gt;The second container.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters>
                    <VarDecl Access="Public" Name="remains" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Union::remains" OverloadKey="::vl::collections::LazyList`1::Union(&amp; const IEnumerable&lt;T&gt;)const::remains" Static="False">
                      <Type>
                        <DecorateTypeDecl Decoration="LeftRef">
                          <Element>
                            <DecorateTypeDecl Decoration="Const">
                              <Element>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </Element>
                            </DecorateTypeDecl>
                          </Element>
                        </DecorateTypeDecl>
                      </Type>
                    </VarDecl>
                  </Parameters>
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <FuncDecl Access="Public" Name="Evaluate" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::Evaluate" OverloadKey="::vl::collections::LazyList`1::Evaluate()const" Virtual="Normal" Function="Function">
              <Type>
                <FunctionTypeDecl CallingConvention="Default" Const="True">
                  <ReturnType>
                    <GenericTypeDecl>
                      <Element>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </Element>
                      <TypeArguments>
                        <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                          </ReferencingOverloadKeys>
                        </RefTypeDecl>
                      </TypeArguments>
                    </GenericTypeDecl>
                  </ReturnType>
                  <Parameters />
                </FunctionTypeDecl>
              </Type>
            </FuncDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list, whose elements are from transformed elements in this lazy list.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a transformation function to transform one element to multiple elements.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::SelectMany`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="SelectMany" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::SelectMany" OverloadKey="::vl::collections::LazyList`1::SelectMany`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType::ResultType" Name="ResultType">
                          <ReferencingOverloadKeys>
                            <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                            <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                          </ReferencingOverloadKeys>
                          <Parent>
                            <GenericTypeDecl>
                              <Element>
                                <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType" Name="FunctionObjectRetriveType">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                                    <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                                  </ReferencingOverloadKeys>
                                  <Parent>
                                    <SubTypeDecl ReferencingNameKey="::vl::function_lambda" Name="function_lambda">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::function_lambda@ns:vl.function_lambda" />
                                      </ReferencingOverloadKeys>
                                      <Parent>
                                        <RefTypeDecl ReferencingNameKey="::vl" Name="vl">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl@ns:vl" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </Parent>
                                    </SubTypeDecl>
                                  </Parent>
                                </SubTypeDecl>
                              </Element>
                              <TypeArguments>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::LazyList`1::SelectMany`1(F)const::F@s:vl.collections.LazyList`1" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </Parent>
                        </SubTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::SelectMany::f" OverloadKey="::vl::collections::LazyList`1::SelectMany`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::SelectMany`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
            <TemplateDecl Access="Public" Tags="x86, Windows">
              <Document>&lt;Document&gt;
  &lt;summary&gt;Create a new lazy list, whose elements are groupd by from elements in this lazy list.&lt;/summary&gt;
  &lt;typeparam name="F"&gt;Type of the lambda expression.&lt;/typeparam&gt;
  &lt;returns&gt;The created lazy list.&lt;/returns&gt;
  &lt;param name="f"&gt;The lambda expression as a key retriver to calcuate a key from an element.&lt;/param&gt;
&lt;/Document&gt;</Document>
              <TypeParameters>
                <TypeParameterDecl Access="Public" Name="F" Tags="x86, Windows" NameKey="::vl::collections::LazyList::F" OverloadKey="::vl::collections::LazyList`1::GroupBy`1(F)const::F" />
              </TypeParameters>
              <Specialization />
              <Element>
                <FuncDecl Access="Public" Name="GroupBy" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::GroupBy" OverloadKey="::vl::collections::LazyList`1::GroupBy`1(F)const" Virtual="Normal" Function="Function">
                  <Type>
                    <FunctionTypeDecl CallingConvention="Default" Const="True">
                      <ReturnType>
                        <GenericTypeDecl>
                          <Element>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Element>
                          <TypeArguments>
                            <GenericTypeDecl>
                              <Element>
                                <RefTypeDecl ReferencingNameKey="::vl::collections::Pair" Name="Pair">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::collections::Pair`2@s:vl.collections.Pair`2" />
                                  </ReferencingOverloadKeys>
                                </RefTypeDecl>
                              </Element>
                              <TypeArguments>
                                <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType::ResultType" Name="ResultType">
                                  <ReferencingOverloadKeys>
                                    <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                                    <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;::ResultType@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                                  </ReferencingOverloadKeys>
                                  <Parent>
                                    <GenericTypeDecl>
                                      <Element>
                                        <SubTypeDecl ReferencingNameKey="::vl::function_lambda::FunctionObjectRetriveType" Name="FunctionObjectRetriveType">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::function_lambda::FunctionObjectRetriveType`1@s:vl.function_lambda.FunctionObjectRetriveType`1" />
                                            <Key Value="::vl::function_lambda::FunctionObjectRetriveType`2&lt;* function (... TArgs) : R&gt;@s:vl.function_lambda.FunctionObjectRetriveType`2{^ function (... TArgs) # R}" />
                                          </ReferencingOverloadKeys>
                                          <Parent>
                                            <SubTypeDecl ReferencingNameKey="::vl::function_lambda" Name="function_lambda">
                                              <ReferencingOverloadKeys>
                                                <Key Value="::vl::function_lambda@ns:vl.function_lambda" />
                                              </ReferencingOverloadKeys>
                                              <Parent>
                                                <RefTypeDecl ReferencingNameKey="::vl" Name="vl">
                                                  <ReferencingOverloadKeys>
                                                    <Key Value="::vl@ns:vl" />
                                                  </ReferencingOverloadKeys>
                                                </RefTypeDecl>
                                              </Parent>
                                            </SubTypeDecl>
                                          </Parent>
                                        </SubTypeDecl>
                                      </Element>
                                      <TypeArguments>
                                        <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                                          <ReferencingOverloadKeys>
                                            <Key Value="::vl::collections::LazyList`1::GroupBy`1(F)const::F@s:vl.collections.LazyList`1" />
                                          </ReferencingOverloadKeys>
                                        </RefTypeDecl>
                                      </TypeArguments>
                                    </GenericTypeDecl>
                                  </Parent>
                                </SubTypeDecl>
                                <GenericTypeDecl>
                                  <Element>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList" Name="LazyList">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </Element>
                                  <TypeArguments>
                                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                                      <ReferencingOverloadKeys>
                                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                                      </ReferencingOverloadKeys>
                                    </RefTypeDecl>
                                  </TypeArguments>
                                </GenericTypeDecl>
                              </TypeArguments>
                            </GenericTypeDecl>
                          </TypeArguments>
                        </GenericTypeDecl>
                      </ReturnType>
                      <Parameters>
                        <VarDecl Access="Public" Name="f" Tags="x64, Windows;x86, Windows" NameKey="::vl::collections::LazyList::GroupBy::f" OverloadKey="::vl::collections::LazyList`1::GroupBy`1(F)const::f" Static="False">
                          <Type>
                            <RefTypeDecl ReferencingNameKey="::vl::collections::LazyList::F" Name="F">
                              <ReferencingOverloadKeys>
                                <Key Value="::vl::collections::LazyList`1::GroupBy`1(F)const::F@s:vl.collections.LazyList`1" />
                              </ReferencingOverloadKeys>
                            </RefTypeDecl>
                          </Type>
                        </VarDecl>
                      </Parameters>
                    </FunctionTypeDecl>
                  </Type>
                </FuncDecl>
              </Element>
            </TemplateDecl>
          </Children>
          <BaseTypes>
            <BaseTypeDecl Access="Public" Tags="x86, Windows">
              <Type>
                <RefTypeDecl ReferencingNameKey="::vl::Object" Name="Object">
                  <ReferencingOverloadKeys>
                    <Key Value="::vl::Object@s:vl.Object" />
                  </ReferencingOverloadKeys>
                </RefTypeDecl>
              </Type>
            </BaseTypeDecl>
            <BaseTypeDecl Access="Public" Tags="x86, Windows">
              <Type>
                <GenericTypeDecl>
                  <Element>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::IEnumerable" Name="IEnumerable">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::IEnumerable`1@s:vl.collections.IEnumerable`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </Element>
                  <TypeArguments>
                    <RefTypeDecl ReferencingNameKey="::vl::collections::T" Name="T">
                      <ReferencingOverloadKeys>
                        <Key Value="::vl::collections::LazyList`1::T@s:vl.collections.LazyList`1" />
                      </ReferencingOverloadKeys>
                    </RefTypeDecl>
                  </TypeArguments>
                </GenericTypeDecl>
              </Type>
            </BaseTypeDecl>
          </BaseTypes>
        </ClassDecl>
      </Element>
    </TemplateDecl>
  </Symbols>
</OverloadingSymbols>